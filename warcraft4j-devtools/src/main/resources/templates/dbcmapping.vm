/*
 * Licensed to the Warcraft4J Project under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The Warcraft4J Project licenses
 * this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package $entry.TargetPackage;

import nl.salp.warcraft4j.files.clientdatabase.DbcEntry;
import nl.salp.warcraft4j.files.clientdatabase.ClientDatabaseEntryType;
import nl.salp.warcraft4j.files.clientdatabase.parser.DbcDataType;
import nl.salp.warcraft4j.files.clientdatabase.parser.DbcField;
import nl.salp.warcraft4j.files.clientdatabase.parser.DbcFile;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;

/**
 * DBC type mapping for {@code $dbc.Name}).
 * <p>
 *   File information for {@code ${dbc.Name}} of type ${dbc.MagicString}:
 *   <ul>
 *      <li>${dbc.Entry.Count} entries</li>
 *      <li>${dbc.Entry.FieldCount} fields per entry</li>
 *      <li>${dbc.Entry.Size} bytes per entry</li>
 *      <li>${dbc.StringTable.Count} entries in the string table</li>
 *      <li>${dbc.StringTable.Size} bytes string table</li>
 *   </ul>
 * </p>
 * <p>
 *   Mapped information for {@link ${entry.Type}}:
 *   <ul>
 *      <li>${entry.Size} bytes per entry</li>
#if ( $entry.isInvalidSize )
 *      <li>FIXME The size of the generated class and the the file entry differ by ${entry.SizeDifference} bytes</li>
#end
#if ( $dbc.StringTable.EntriesAvailable )
 *      <li>FIXME There are ${dbc.StringTable.Count} string table entries available for ${dbc.Entry.Count} entries, but non are mapped</li>
#end
 *   </ul>
 * </p>
 * <p>
 * TODO Replace the fields in this file with coherent field naming and proper data types.
 * <p>
 *
 * @author ${author}
 */
@DbcFile(file = "${dbc.Name}")
public class ${entry.Type} implements DbcEntry {
    /** The {@link DbcType} for the DBC mapping entry. */
    private static final DbcType ENTRY_TYPE = DbcType.${entry.DbcType};

    /** The entry id. */
    @DbcField(order = 1, dataType = DbcDataType.UINT32)
    private int id;

#foreach($i in [1..$dbc.Entry.FieldCount])
    #set ( $fieldIndex = $i + 1 )
    /** TODO Replace field unknown${fieldIndex} with the proper data type and coherent name. */
    @DbcField(order = ${fieldIndex}, dataType = DbcDataType.UINT32, knownMeaning = false)
    private int unknown${fieldIndex};

#end
    @Override
    public ClientDatabaseEntryType getEntryType() {
        return ENTRY_TYPE;
    }

    @Override
    public int getId() {
        return id;
    }

#foreach($i in [1..$dbc.Entry.FieldCount])
    #set ( $fieldIndex = $i + 1 )
    /**
     * Get the ${fieldIndex} unknown field value.
     * <p/>
     * TODO Replace field unknown${fieldIndex} with the proper data type and coherent name.
     *
     * @return The value.
     */
    @Deprecated
    public int getUnknown${fieldIndex}() {
        return this.unknown${fieldIndex};
    }

#end
    @Override
    public boolean equals(Object obj) {
        return EqualsBuilder.reflectionEquals(this, obj);
    }

    @Override
    public int hashCode() {
        return HashCodeBuilder.reflectionHashCode(this);
    }

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }
}